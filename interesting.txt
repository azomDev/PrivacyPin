### **Non-Interactive One-Way Privacy-Preserving Challenge Authentication Protocol**

#### **1. Request Initiation**  

On the client side:
1. **Generate Challenge**: A **nonce** (random value) is created to serve as the challenge.
3. **Sign Data**: The **request body**, **timestamp**, **challenge**, and **user ID** are signed using the client’s private key, preventing tampering.
4. **Transmit to Server**: The client sends the **signed request body**, along with the **challenge**, **timestamp**, and **user ID**, to the server.

---

### **2. Server Side**

1. **Receive Request**: The server receives the signed request, including the **challenge**, **timestamp**, and **user ID**.

2. **Timestamp Validation**: The server checks if the **timestamp** is within an acceptable window (e.g., last X seconds). If it's outdated, the request is **denied** to protect against **Message Delaying Attacks**.

3. **Signature Verification**: The server verifies the **signature** to ensure the request data hasn't been tampered with.

4. **Challenge Lookup**: The server checks if the **challenge** exists in the short-term memory database, which is global and stores anonymized challenges from all users within the last X seconds. This prevents identifying which user the challenge belongs to. If the challenge is found, the request is denied, as the challenge has already been processed.

5. **Challenge Expiration and Cleanup**: Challenges are stored in the database with a **cleanup index** (currentIndex + 2 mod 3). The server runs a cleanup process every Y seconds (such that Y>X seconds to prevent replay attacks), removing expired challenges at the **current index**. The index wraps around at 3 (mod 3) to maintain privacy, preventing external observers from knowing the server’s uptime.

6. **Authorization**: If the **challenge** is not found in the database, the server **accepts the request**, processes it, and sends a response back to the client.


Full Name: Challenge-Based Lightweight One-Way Authentication with Keyed Privacy
